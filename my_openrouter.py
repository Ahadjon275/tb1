#!/usr/bin/env python3

import random
import threading

import openai
from sqlitedict import SqliteDict

import cfg
import utils
import my_log


# память диалогов {id:messages: list}
CHATS = SqliteDict('db/dialogs_openrouter.db', autocommit=True)

# замки диалогов {id:lock}
CHAT_LOCKS = {}


MAX_CHAT_LINES = 20
MAX_HIST_BYTES = 7000
MAX_QUERY = 4000


def ai(prompt: str = '', timeou: int = 120, messages = None,
       model_to_use: str = 'google/gemma-7b-it:free') -> str:
    """Сырой текстовый запрос, возвращает сырой ответ
    """

    if messages == None:
        assert prompt != '', 'prompt не может быть пустым'
        messages = [{"role": "system", "content": """Ты искусственный интеллект отвечающий на запросы юзера."""},
                    {"role": "user", "content": prompt}]

    base_url = 'https://openrouter.ai/api/v1'

    if hasattr(cfg, 'openrouter_api') and cfg.openrouter_api:
        api_key = random.choice(cfg.openrouter_api)
    else:
        return ''

    response = ''

    try:
        client = openai.OpenAI(api_key = api_key, base_url = base_url)

        completion = client.chat.completions.create(
            model = model_to_use,
            messages=messages,
            # max_tokens=max_tok,
            # temperature=temp,
            timeout=timeou
        )
        response = completion.choices[0].message.content
    except Exception as unknown_error1:
        my_log.log2(f'my_openrouter.ai: {unknown_error1}\n\nServer: {openai.base_url}')

    return response


def get_mem_as_string(chat_id_full: str) ->str:
    # обрезаем историю
    try:
        CHATS[chat_id_full] = CHATS[chat_id_full][-cfg.max_hist_lines:]
    except:
        pass

    if chat_id_full in CHATS:
        messages = CHATS[chat_id_full]
        messages2 = []
        for x in messages:
            if x['content'].startswith('[Info to help you answer'):
                end = x['content'].find(']') + 1
                x['content'] = x['content'][end:]
            messages2.append(x)
        prompt = '\n'.join(f'{"𝐔𝐒𝐄𝐑" if i["role"] == "user" else "𝐁𝐎𝐓" if i["role"] == "assistant" else "𝐒𝐘𝐒𝐓𝐄𝐌"} - {i["content"]}\n' for i in messages2) or ''
        prompt = prompt.replace('\n𝐁𝐎𝐓','𝐁𝐎𝐓')
    else:
        prompt = ''
    return prompt



def chat(chat_id: str, query: str) -> str:
    """
    The chat function is responsible for handling user queries and generating responses
    using the ChatGPT model.

    Parameters:
    - chat_id: str, the ID of the chat
    - query: str, the user's query
    - user_name: str, the user's name (default: 'noname')
    - lang: str, the language of the chat (default: 'ru')
    - is_private: bool, indicates whether the chat is private or not (default: True)
    - chat_name: str, the name of the chat (default: 'noname chat')

    Returns:
    - str, the response generated by the ChatGPT model
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        # в каждом чате своя история диалога бота с юзером
        if chat_id in CHATS:
            messages = CHATS[chat_id]
        else:
            messages = []
        # теперь ее надо почистить что бы влезла в запрос к GPT
        # просто удаляем все кроме max_hist_lines последних
        if len(messages) > MAX_CHAT_LINES:
            messages = messages[MAX_CHAT_LINES:]
        # удаляем первую запись в истории до тех пор пока общее количество токенов не
        # станет меньше MAX_HIST_BYTES
        # удаляем по 2 сразу так как первая - промпт для бота
        while utils.count_tokens(messages) > MAX_HIST_BYTES:
            messages = messages[2:]
        # добавляем в историю новый запрос и отправляем
        messages = messages + [{"role":    "user",
                                "content": query}]

        current_prompt = []

        # пытаемся получить ответ
        resp = ''
        try:
            resp = ai(prompt = '', messages = current_prompt + messages)
            if resp:
                messages = messages + [{"role":    "assistant",
                                        "content": resp}]
            else:
                # не сохраняем диалог, нет ответа
                # если в последнем сообщении нет текста (глюк) то убираем его
                if messages[-1]['content'].strip() == '':
                    messages = messages[:-1]
                CHATS[chat_id] = messages or []
                return ''
        # бот не ответил или обиделся
        except AttributeError:
            # не сохраняем диалог, нет ответа
            return ''
        # произошла ошибка переполнения ответа
        except openai.BadRequestError as error2:
            my_log.log2(error2)
            return ''

        CHATS[chat_id] = messages or []

        return resp or ''


def undo(chat_id: str):
    """
    Undo the last two lines of chat history for a given chat ID.

    Args:
        chat_id (str): The ID of the chat.
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        if chat_id in CHATS:
            CHATS[chat_id] = CHATS[chat_id][:-2]


def chat_reset(chat_id: str):
    """
    Reset the chat with the given chat_id.
    
    Parameters:
        chat_id (str): The ID of the chat to reset.
    
    Returns:
        None
    """
    if chat_id in CHAT_LOCKS:
        lock = CHAT_LOCKS[chat_id]
    else:
        lock = threading.Lock()
        CHAT_LOCKS[chat_id] = lock

    with lock:
        if chat_id in CHATS:
            CHATS[chat_id] = []


def console_chat_test():
    """
    This function is a console chat test. It allows the user to interact with a chatbot
    by entering queries in the console. The function takes no parameters.

    Parameters:
        None

    Returns:
        None
    """
    chat_id = 'test'

    while True:
        query = input('> ')
        if query == 'exit':
            break
        if query == 'clear':
            chat_reset(chat_id=chat_id)
            print('OK')
            continue
        if query == 'mem':
            print('')
            mem = [x for x in CHATS[chat_id]]
            for x in mem:
                print(x)
            print('')
            continue
        response = chat(chat_id='test', query=query)
        print(response)


if __name__ == '__main__':
    # print(ai('hi'))
    console_chat_test()